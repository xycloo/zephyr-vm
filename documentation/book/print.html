<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Zephyr Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">2.</strong> Concepts SDK API</a></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">3.</strong> Setup</a></li><li class="chapter-item expanded "><a href="hello-ledger.html"><strong aria-hidden="true">4.</strong> Write a Hello Ledger Program</a></li><li class="chapter-item expanded "><a href="hello-ledger-cli.html"><strong aria-hidden="true">5.</strong> Zephyr CLI: Create table and Upload</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">6.</strong> Other examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contracts-map.html"><strong aria-hidden="true">6.1.</strong> Track Network SAC Contracts</a></li><li class="chapter-item expanded "><a href="sac-events.track.html"><strong aria-hidden="true">6.2.</strong> Track SAC Events</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Zephyr Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="zephyr-empowering-mercury-users-with-custom-extensions-to-our-ingestion"><a class="header" href="#zephyr-empowering-mercury-users-with-custom-extensions-to-our-ingestion">Zephyr: Empowering Mercury Users with Custom Extensions to our Ingestion.</a></h1>
<p>Welcome to the documentation for Zephyr, a code execution environment designed to enhance the capabilities of Mercury, the data indexer built by <a href="https://xycloo.com">xyclooLabs</a> designed
to fit all the needs of developers and users of the Stellar Network, and where Soroban is a first-class citizen.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Zephyr is a Virtual Machine developed on top of WebAssembly. This technology enables the execution of WASM modules
within Mercury's ingestion flow, providing seamless access to the Stellar network's data stored in Mercury's database and ledger metadata. </p>
<p>The decision to build on WebAssembly stems from its proven efficiency, safety features developed in Rust, and its 
ability to offer a secure execution environment for users and infrastructure alike.</p>
<p>Zephyr's integration with Mercury unlocks a plethora of possibilities for the Stellar ecosystem. 
Users can now build specialized services without the need for setup or infrastructure. 
From protocol-centered services to user-specific applications, the Mercury + Zephyr combination opens up a world of innovative use cases.</p>
<p>Some use cases that are currently <strong>only partially possible</strong>* are:</p>
<ul>
<li>Advanced Alert Systems: Empower traders and arbitrageurs to build highly customized alert and trading strategies without the complexities of managing databases or running instances.</li>
<li>Trackers: Effortlessly create watcher services to track the movement of funds across the Stellar network.</li>
<li>Multi-step Workflows: Facilitate complex processes by enabling workflows where each step depends on the result of the previous one.</li>
<li>Customized Indexing: Tailor database structures to specific querying needs with Zephyr's ingestion mechanisms.</li>
<li>User-defined Data Aggregations: Define personalized aggregation functions and calculations for unique requirements.</li>
<li>On-the-fly Subscriptions: Dynamically create subscriptions for specific data, allowing for real-time monitoring.</li>
<li>Custom Data Retention Policies: Empower users to manage data retention based on custom policies, optimizing costs in the long run.</li>
<li>Protocol Health Checks: Easily deploy watcher programs to monitor and maintain the health of protocols within the Stellar ecosystem.</li>
</ul>
<p>*<em>The latest release of the Zephyr VM and its integration within Mercury is still very experimental and a lot of key features are
still missing (websockets, custom querying, more advanced DB access, making subscriptions, conditional triggering and others).</em></p>
<hr/>
<p>If this looks interesting enough and you whish to try it out, proceed to the next section to setup your projects to
work with Zephyr. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts-sdk-api-definition"><a class="header" href="#concepts-sdk-api-definition">Concepts SDK API Definition</a></h1>
<p>Below there are some important concepts about the ZephyrVM integration. We recommend reading
this section before getting hands-on with the tutorial in the next sections.</p>
<h2 id="runs-for-every-ledger"><a class="header" href="#runs-for-every-ledger">Runs for every ledger</a></h2>
<p>Zephyr programs run sequentially for every new ledger that is closed in the network.
This means that once your program is deployed it will be run for every new ledger close
since the moment of deployment. This is at least until we introduce conditional execution
that will make Zephyr less expensive.</p>
<h2 id="before-you-deploy"><a class="header" href="#before-you-deploy">Before you deploy</a></h2>
<p>Before you deploy your program and expect for it to start working immediately, it's important 
to know that you are going to need to correctly create all the tables that your program accesses.</p>
<p>In fact the general workflow for working with Zephyr is:</p>
<ol>
<li>write the program and take note of the tables and columns you access.</li>
<li>create these tables with the columns in the database through the CLI.</li>
<li>deploy the program.</li>
</ol>
<p>If you deploy the program without having first created the <strong>correct</strong> tables through the CLI
the execution of the program will always exit unsuccessfully, and currently there isn't a loggin
infra available to users that makes this easy to detect.</p>
<h2 id="symbols-inherited-from-soroban"><a class="header" href="#symbols-inherited-from-soroban">Symbols inherited from Soroban</a></h2>
<p>For ease of implementation all table names and table columns are pretty much Soroban symbols. This means
that they undergo all of the constraints that Soroban symbols have. They cannot exceed 9 characters and valid characters are <code>a-zA-Z0-9_</code>. This is an efficiency-driven decision. </p>
<p>Since unlike the Soroban VM we are using WASM's multivalue feature, we're considering extending the lenght 
of a symbol but it's not currently implemented. </p>
<h2 id="slice-based-communication"><a class="header" href="#slice-based-communication">Slice-based communication</a></h2>
<p>Currently we haven't implemented any Zephyr types yet, so when you write and read from the database, you're
in charge of serializing/deserializing the contents to/from a bytes slice. This will become clearer once you
take a look at the next sections.</p>
<h2 id="environemnt"><a class="header" href="#environemnt">Environemnt</a></h2>
<p>The guest program, i.e your program will access the database and ledger close metas thorugh the <code>Env</code> object
exported by the SDK.</p>
<p>This object has currently the following functions:</p>
<ul>
<li>
<p><code>db_write(&amp;self, table_name: &amp;str, columns: &amp;[&amp;str], segments: &amp;[&amp;[u8]]) -&gt; Result&lt;(), SdkError&gt;</code> which writes 
to the DB's <code>table</code> table the specified columns with the specified <code>segments</code> of data (always as byte slices).</p>
</li>
<li>
<p><code>db_read(&amp;self, table_name: &amp;str, columns: &amp;[&amp;str]) -&gt; Result&lt;TableRows, SdkError&gt;</code> which reads from 
the DB's <code>table</code> table the specified columns. This returns a <code>TableRows</code> object which wraps all the rows and columns:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current implementation treats these as named structs, but could change.
#[derive(Clone, Deserialize, Serialize)]
pub struct TableRows {
    pub rows: Vec&lt;TableRow&gt;,
}

#[derive(Clone, Deserialize, Serialize)]
pub struct TableRow {
    pub row: Vec&lt;TypeWrap&gt;,
}

#[derive(Clone, Deserialize, Serialize)]
pub struct TypeWrap(pub Vec&lt;u8&gt;);
<span class="boring">}</span></code></pre></pre>
<p>As you can see <code>TablesRows</code> wraps the rows, and each <code>TableRow</code> wraps each requested column. The value in each 
column for each row is <code>TypeWrap</code>, so a vectory of bytes.</p>
<ul>
<li>
<p><code>reader(&amp;mut self) -&gt; MetaReader</code> returns the <code>MetaReader</code> object, which should help you in getting
sections of the ledger meta more easily. However, the current implementation of the <code>MetaReader</code> is very limited.
If you're searching for a part of the metadata that isn't easily extracted through the reader then use the <code>last_ledger_meta_xdr()</code> function.</p>
</li>
<li>
<p><code>last_ledger_meta_xdr(&amp;mut self) -&gt; &amp;stellar_xdr::next::LedgerCloseMeta</code> which returns the whole <code>LedgerCloseMeta</code>
object (from Stellar's XDR definition).</p>
</li>
</ul>
<h2 id="zephyrs-db-access"><a class="header" href="#zephyrs-db-access">Zephyr's DB Access</a></h2>
<p>Of course, Zephyr-executed programs have strict limitations on database writes and reads. Mainly access limitations
for now. Only zephyr tables (created through the CLI) created by your account are accessible. Mercury built-in tables
(contract events, ledger entries, payments, etc) will never be able to be written by Zephyr and are currently not able
to be read (though we plan on enabling this once we write the authorization part for this). </p>
<h2 id="querying-zephyr-tables"><a class="header" href="#querying-zephyr-tables">Querying Zephyr Tables</a></h2>
<p>Zephyr tables your create and access don't actually show up with the name you give them in the database. Rather they 
are a md5 hash of the table name you provide and your Mercury user id. This means that when querying your Zephyr table 
through GraphQL you don't query the table name rather the hash.</p>
<p>This is how the hash is generated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let id = {
    let value = host.get_host_id();
    byte_utils::i64_to_bytes(value)
};

let write_point_hash: [u8; 16] = {
    let point_raw = stack.first().ok_or(HostError::NoValOnStack)?;
    let point_bytes = byte_utils::i64_to_bytes(*point_raw);

    md5::compute([point_bytes, id].concat()).into()
};
<span class="boring">}</span></code></pre></pre>
<p>Basically, you compute the hash of the i64 repr of the table name symbol concatenated with your user id. Anyways, the
CLI will output the actual table name queryable from GraphQL once you deploy the table.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-your-project"><a class="header" href="#setup-your-project">Setup your Project</a></h1>
<blockquote>
<p>Note: this section assumes that you have already gone through at least the first steps of the <a href="https://soroban.stellar.org/docs/getting-started/setup">Soroban's setup</a>.
If you haven't, you'll need to install rust and add <code>wasm32-unknown-unknown</code> as target.</p>
</blockquote>
<h2 id="install-the-zephyr-cli"><a class="header" href="#install-the-zephyr-cli">Install the Zephyr CLI</a></h2>
<p>The Zephyr CLI will be needed to upload your programs and create the tables these will access.</p>
<pre><code>cargo install zephyr-cli
</code></pre>
<h2 id="initialize-the-project"><a class="header" href="#initialize-the-project">Initialize the project</a></h2>
<p>First, you need to create a new cargo library:</p>
<pre><code>cargo new --lib zephyr-hello-ledger 
</code></pre>
<h2 id="add-zephyr-sdk-as-dependency"><a class="header" href="#add-zephyr-sdk-as-dependency">Add Zephyr SDK as Dependency</a></h2>
<p>Next, you'll need to add the zephyr sdk to your dependencies.
This will enable you to easily access the environment without directly communicating with it or with shared linear memory.</p>
<pre><code class="language-toml">[package]
name = &quot;zephyr-hello-ledger&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rs-zephyr-sdk = { path=&quot;../zephyr/rs-zephyr-sdk&quot; }

[lib]
crate-type = [&quot;cdylib&quot;]

[profile.release]
opt-level = &quot;z&quot;
overflow-checks = true
debug = 0
strip = &quot;symbols&quot;
debug-assertions = false
panic = &quot;abort&quot;
codegen-units = 1
lto = true

</code></pre>
<p>Also, we've set <code>cdylib</code> as crate type to produce a dynamic library and set some release flags in order
not to produce md-large binaries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-a-hello-ledger-program"><a class="header" href="#write-a-hello-ledger-program">Write a Hello Ledger Program</a></h1>
<p>Now it's time to write a very simple zephyr program that for every ledger that passes will write to a table <code>ledgers</code> the ledger sequence and the amount of transactions in the ledger's tx processing.</p>
<h2 id="entry-point"><a class="header" href="#entry-point">Entry point</a></h2>
<p>The Zephyr environment will automatically only call a <code>on_close() -&gt; ()</code> function. If such function isn't exported by the WASM module there will be no execution.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn on_close() {}
<span class="boring">}</span></code></pre></pre>
<p>We disable mangling and tell the compiler this function has a c interface.</p>
<h2 id="getting-ledger-number-and-tx-processing-count"><a class="header" href="#getting-ledger-number-and-tx-processing-count">Getting ledger number and tx processing count</a></h2>
<p>Next up is accessing the ledger meta to read the ledger sequence and number of transactions in the ledger's transaction processing section. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut env = EnvClient::default();
let reader = env.reader();

let sequence = reader.ledger_sequence();
let processing = reader.tx_processing();
let processing_length = processing.len();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that the <code>reader</code> is currently very incomplete and there are high chances that you'll
have to deal with the hole ledger meta object yourself.
In such cases, the usage of <code>let meta = env.last_ledger_meta_xdr()</code> is recommended.</p>
</blockquote>
<h2 id="writing-to-the-database"><a class="header" href="#writing-to-the-database">Writing to the database</a></h2>
<p>Lastly, we want to write the sequence and the processing to the database's <code>ledgers</code> table:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env.db_write(&quot;ledgers&quot;, 
    &amp;[
        &quot;sequence&quot;, 
        &quot;proc&quot;
    ], 
    &amp;[
        &amp;sequence.to_be_bytes(), 
        &amp;processing_length.to_be_bytes()]
    ).unwrap();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that we're transforming the sequence and processing lenght to an array of bytes.
This is needed as currently the only type we've defined to work with Zephyr host &lt;&gt; guest
communication is raw bytes. As SDK development goes further there will be more types (Arrays, Strings, Numbers, etc) that can be sent.</p>
</blockquote>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In the end, our Zephyr program should look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rs_zephyr_sdk::EnvClient;


#[no_mangle]
pub extern &quot;C&quot; fn on_close() {
    let mut env = EnvClient::default();
    let reader = env.reader();

    let sequence = reader.ledger_sequence();
    let processing = reader.tx_processing();
    let processing_length = processing.len();

    env.db_write(&quot;ledgers&quot;, 
    &amp;[
        &quot;sequence&quot;, 
        &quot;proc&quot;
    ], 
    &amp;[
        &amp;sequence.to_be_bytes(), 
        &amp;processing_length.to_be_bytes()]
    ).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h1 id="compiling"><a class="header" href="#compiling">Compiling</a></h1>
<p>To compile the program to WASM:</p>
<pre><code>cargo +nightly rustc --release --target=wasm32-unknown-unknown -- -C target-feature=+multivalue
</code></pre>
<p>As you can see, we're targeting a WASM release and we're also enabling WASM's multivalue compilation.
Multivalue is used in Zephyr for efficiency of host &lt;&gt; guest interop. </p>
<p>This should compile the program to <code>target/wasm32-unknown-unknown/release/zephyr_hello_ledger.wasm</code>.</p>
<p>If you wish to optimize the program size, you can also use:</p>
<pre><code>wasm-opt -Oz -o ./target/wasm32-unknown-unknown/release/zephyr_hello_ledger.optimized.wasm  ./target/wasm32-unknown-unknown/release/zephyr_hello_ledger.wasm --enable-multivalue
</code></pre>
<hr/>
<p>The last step is to crete the <code>ledgers</code> table and upload the program. See the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zephyr-cli-create-table-and-upload"><a class="header" href="#zephyr-cli-create-table-and-upload">Zephyr CLI: Create table and Upload</a></h1>
<h2 id="create-the-ledgers-table"><a class="header" href="#create-the-ledgers-table">Create the ledgers table</a></h2>
<pre><code>zephyr --jwt $JWT_TOKEN new-table --name &quot;ledgers&quot; --columns 'sequence' 'proc'

[+] Table &quot;zephyr_d625b7bb470ff3fe8cd1351a1cbb7187&quot; created successfully
</code></pre>
<blockquote>
<p>Note that table name and columns must abide to Soroban's short symbol rules. In fact they cannot exceed 9 characters and valid characters are <code>a-zA-Z0-9_</code>. This is an efficiency-driven decision. We are also considering extending the lenght using multivalue but it's not currently implemented. </p>
</blockquote>
<p>The above command will create the ledgers table (pertinent to the user specified by the jwt token) with columns <code>sequence</code> and <code>proc</code>.</p>
<h2 id="upload"><a class="header" href="#upload">Upload</a></h2>
<p>Only after having created all the needed tables (with correct columns) you can upload your program:</p>
<pre><code>zephyr --jwt $JWT_TOKEN deploy --wasm ./target/wasm32-unknown-unknown/release/zephyr_hello_ledger.optimized.wasm
</code></pre>
<h2 id="query"><a class="header" href="#query">Query</a></h2>
<p>Now I can query all rows in my zephyr table:</p>
<pre><code class="language-graphql">query MyQuery {
  allZephyrD625B7Bb470Ff3Fe8Cd1351A1Cbb7187S {
    edges {
      node {
        sequence
        proc
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;allZephyrD625B7Bb470Ff3Fe8Cd1351A1Cbb7187S&quot;: {
      &quot;edges&quot;: [
        {
          &quot;node&quot;: {
            &quot;sequence&quot;: &quot;\\x000280d3&quot;,
            &quot;proc&quot;: &quot;\\x00000002&quot;
          }
        },
        {&quot;more&quot;: &quot;nodes&quot;}
      ]
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Below are some of the examples we've written as of now. If you've built something using
zephyr and want it to appear here, we'd love for you to open an issue for it <a href="https://github.com/xycloo/zephyr/issues">here</a>.</p>
<p>These can be found also on <a href="https://github.com/xycloo/zephyr-examples">the Github repo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-sac-contracts"><a class="header" href="#network-sac-contracts">Network SAC Contracts</a></h1>
<p>This program monitors the chain for every time a Stellar Asset contract is wrapped, enabling
Soroban usage of that token.</p>
<p>It also pushes to a table the total amount of deployed SACs by ledger, allowing to potentially
see the trend in the growth of wrapped assets.</p>
<p>This table is public and can be queried as follows through the Mercury endpoint:</p>
<pre><code class="language-graphql">query SACTrend {
  allZephyr263707E6Cf91Cece33596A294D312A5Ds {
    edges {
      node {
        sequence
        number
      }
    }
  }
}

query AllSACs {
  allZephyrB8978D969636A31Fe5E95Efe542A1536S {
    edges {
      node {
        contract
        asset
      }
    }
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rs_zephyr_sdk::{
    stellar_xdr::next::{
        ContractIdPreimage, FeeBumpTransactionInnerTx, HostFunction, LedgerKey, Limits,
        OperationBody, ScAddress, TransactionEnvelope, TransactionExt, TransactionResultMeta,
        TransactionResultResult, TransactionV1Envelope, WriteXdr,
    },
    EnvClient,
};

struct CreatedSAC {
    contract_id: [u8; 32],
    asset: Vec&lt;u8&gt;,
}

#[no_mangle]
pub extern &quot;C&quot; fn on_close() {
    let mut env = EnvClient::default();
    let reader = env.reader();

    let envelopes = reader.envelopes();
    let processing = reader.tx_processing();
    let current_ledger = reader.ledger_sequence();

    let mut created = Vec::new();

    for (idx, envelope) in envelopes.iter().enumerate() {
        match envelope {
            TransactionEnvelope::Tx(tx) =&gt; write_from_v1(idx, tx, &amp;processing, &amp;mut created),

            // v0 txs cannot inlcude soroban data
            TransactionEnvelope::TxV0(_) =&gt; (),

            TransactionEnvelope::TxFeeBump(tx) =&gt; match &amp;tx.tx.inner_tx {
                FeeBumpTransactionInnerTx::Tx(tx) =&gt; {
                    write_from_v1(idx, &amp;tx, &amp;processing, &amp;mut created)
                }
            },
        }
    }

    // add all created SACs to the database.
    for sac in &amp;created {
        env.db_write(
            &quot;sacs&quot;,
            &amp;[&quot;contract&quot;, &quot;asset&quot;],
            &amp;[&amp;sac.contract_id, &amp;sac.asset],
        )
        .unwrap();
    }

    // if no SAC was deployed add new record into historical trend
    let num_created = created.len() as i64;
    if num_created &gt; 0 {
        let previous_sacs = env.db_read(&quot;sac_count&quot;, &amp;[&quot;number&quot;]);
        if let Ok(rows) = previous_sacs {
            if let Some(last) = rows.rows.last() {
                let mut byte_array: [u8; 8] = [0; 8];
                let int = &amp;last.row[0].0;
                byte_array.copy_from_slice(&amp;int[..int.len()]);
                let tot_sacs = i64::from_be_bytes(byte_array) + num_created;

                env.db_write(
                    &quot;sac_count&quot;,
                    &amp;[&quot;sequence&quot;, &quot;number&quot;],
                    &amp;[&amp;current_ledger.to_be_bytes(), &amp;tot_sacs.to_be_bytes()],
                )
                .unwrap()
            } else {
                env.db_write(
                    &quot;sac_count&quot;,
                    &amp;[&quot;sequence&quot;, &quot;number&quot;],
                    &amp;[&amp;current_ledger.to_be_bytes(), &amp;num_created.to_be_bytes()],
                )
                .unwrap()
            }
        }
    }
}

fn write_from_v1(
    idx: usize,
    tx: &amp;TransactionV1Envelope,
    processing: &amp;Vec&lt;TransactionResultMeta&gt;,
    created: &amp;mut Vec&lt;CreatedSAC&gt;,
) {
    match &amp;tx.tx.operations.get(0).unwrap().body {
        // we search for create SAC operations
        OperationBody::InvokeHostFunction(op) =&gt; {
            if let HostFunction::CreateContract(create_contract) = &amp;op.host_function {
                if let ContractIdPreimage::Asset(asset) = &amp;create_contract.contract_id_preimage {
                    let matching_processing = processing.get(idx).unwrap();

                    // we make sure that the tx was successful
                    if let TransactionResultResult::TxSuccess(_) =
                        matching_processing.result.result.result
                    {
                        if let TransactionExt::V1(soroban) = &amp;tx.tx.ext {
                            if let LedgerKey::ContractData(data) =
                                &amp;soroban.resources.footprint.read_write[0]
                            {
                                if let ScAddress::Contract(contract) = &amp;data.contract {
                                    created.push(CreatedSAC {
                                        contract_id: contract.0,
                                        asset: asset.to_xdr(Limits::none()).unwrap(),
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }

        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="track-sac-events"><a class="header" href="#track-sac-events">Track SAC Events</a></h1>
<blockquote>
<p>Note: this program relies on the previous SAC tracker program.</p>
</blockquote>
<p>This program tracks all events of the SACs registered from the <a href="./contracts-map.html">previous</a> program.</p>
<h3 id="currently-deployed-version"><a class="header" href="#currently-deployed-version">Currently deployed version</a></h3>
<p>This program is already live on Zephyr and is tracking events for SACs wrapped in and after ledger <code>177442</code> 
and its data can be accessed as follows:</p>
<pre><code class="language-graphql">query SACEvents {
  allZephyr86882807C5E507349D54F6F33Fc8229As {
    edges {
      node {
        sequence
        contract
        topic1
        topic2
        topic3
        topic4
        data
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;allZephyr86882807C5E507349D54F6F33Fc8229As&quot;: {
      &quot;edges&quot;: [
        {
          &quot;node&quot;: {
            &quot;sequence&quot;: &quot;\\x0002b522&quot;,
            &quot;contract&quot;: &quot;\\xc184ad97f64befba0907b3cef6b570155c16658fcef92df221147d1592faa3e0&quot;,
            &quot;topic1&quot;: &quot;\\x0000000f000000046d696e74&quot;,
            &quot;topic2&quot;: &quot;\\x000000120000000000000000d08a167b577b96595971d6884e6a3097affb238ca5947585ead11660fa23676f&quot;,
            &quot;topic3&quot;: &quot;\\x00000012000000000000000047447cded9fa966bd551e683c1d39d5e9b32361f1a6483c15382f7684751bea0&quot;,
            &quot;topic4&quot;: &quot;\\x0000000e0000003c54454d3a47444949554654334b35355a4d574b5a4f484c495154544b47434c3237365a445253535a49354d46354c49524d594832454e545737374248&quot;,
            &quot;data&quot;: &quot;\\x0000000a00000000000000000000000000000190&quot;
          }
        }
      ]
    }
  }
}
</code></pre>
<p>Remember that all this data is hex encoded bytes. <code>topicn</code> and <code>data</code> should be parsed as ScVals 
(<code>ScVal::from_xdr(...)</code>), <code>contract</code> is the inner <code>Hash(&lt;this is contract&gt;)</code> so you can easily build the 
corresponding string using the stellar-strkey libs. <code>sequence</code> is the big endian bytes repr for an <code>i64</code>. 
For example you can parse it in js as follows</p>
<pre><code class="language-js">const hex = &quot;\\x0002b522&quot;;
const cleanHex = hex.replace(/\\x/g, '');
const result = parseInt(cleanHex, 16);

console.log(result);
</code></pre>
<h1 id="code"><a class="header" href="#code">Code</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rs_zephyr_sdk::{
    stellar_xdr::next::{ContractEventBody, Limits, TransactionMeta, WriteXdr},
    EnvClient,
};

#[no_mangle]
pub extern &quot;C&quot; fn on_close() {
    let mut env = EnvClient::default();
    let reader = env.reader();

    let sequence = reader.ledger_sequence();
    let processing = reader.tx_processing();

    let sacs = env.db_read(&quot;sacs&quot;, &amp;[&quot;contract&quot;]).unwrap();
    let tracked_deployed_sacs: Vec&lt;&amp;Vec&lt;u8&gt;&gt; = sacs.rows.iter().map(|row| &amp;row.row[0].0).collect();

    for tx_processing in processing {
        if let TransactionMeta::V3(meta) = &amp;tx_processing.tx_apply_processing {
            if let Some(soroban) = &amp;meta.soroban_meta {
                if !soroban.events.is_empty() {
                    for event in soroban.events.iter() {
                        let contract_id = event.contract_id.as_ref().unwrap().0;
                        if tracked_deployed_sacs.contains(&amp;contract_id.to_vec().as_ref()) {
                            let (topics, data) = match &amp;event.body {
                                ContractEventBody::V0(v0) =&gt; (
                                    v0.topics
                                        .iter()
                                        .map(|topic| topic.to_xdr(Limits::none()).unwrap())
                                        .collect::&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;(),
                                    v0.data.to_xdr(Limits::none()).unwrap(),
                                ),
                            };
                            env.db_write(
                                &quot;sac_event&quot;,
                                &amp;[
                                    &quot;sequence&quot;, &quot;contract&quot;, &quot;topic1&quot;, &quot;topic2&quot;, &quot;topic3&quot;, &quot;topic4&quot;,
                                    &quot;data&quot;,
                                ],
                                &amp;[
                                    &amp;sequence.to_be_bytes(),
                                    &amp;contract_id,
                                    &amp;topics.get(0).unwrap_or(&amp;vec![]),
                                    &amp;topics.get(1).unwrap_or(&amp;vec![]),
                                    &amp;topics.get(2).unwrap_or(&amp;vec![]),
                                    &amp;topics.get(3).unwrap_or(&amp;vec![]),
                                    &amp;data,
                                ],
                            )
                            .unwrap()
                        }
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
